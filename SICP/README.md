## 2017-04-01 (Sat)

* 존재하지 않는 symbol 에 대해 `set!` procedure 를 호출하면 에러가 발생한다. 그래서 초기값을 `define` 구문으로 정의하고 그에 대해 `set!` procedure 를 호출해야되서 불편했다. 3.2 절을 읽으니 왜 그랬는지 이해가 된다. `set!` procedure 를 호출하면, symbol 을 찾아서 frame sequence 를 순회하고, 처음으로 발견한 binding 의 value 를 교체하는 식으로 동작하기 때문이다.
* recursive process 는 stack machine 과, iterative process 는 register machine 과 연관됬었다는 점을 **Chapter 1.2.1** 를 다시 읽으며 깨우쳤다. returned value 가 call to call 로 전달되는 개념에 대해서 Chapter 5 를 예고했었는데, 여기서도 Chapter 5 를 예고한다. **recursive procedure** 면서 **iterative process** 인게 가능하다는걸 기억하자. 예를 들어 `factorial` 을 `factorial-iter` 로 구현하면 `factorial-iter` 이 자기 자신을 호출하므로 recursive procedure 지만, 또한  iterative process 이다. recursion 연산이 펼쳐지는게 아니라 매번 state 를 갱신하면서 자기 자신을 호출하기 때문이다. 하지만 modern 프로그래밍 언어들은 recursion 으로 프로그래밍하면 새로운 procedure 호출이 있을때마다 새로운 stack 을 만든다. 그러므로 필요한 메모리 공간의 크기가 recursion 깊이에 비례하게되어 iterative process 로 recursion 을 구현할 수 없다. 따라서 iterative process 를 위한 특별한 구문을 제공하는데 그게 바로 `for`, `while` 등의 반복문이다. 이와 달리 Scheme 은 언어 차원에서 iterative process 를 제공하는데 이를 `tail recursion` 이라고 부른다.
* 졸립지만 자기전에 신속하게 3.2.4 절을 훑으며 읽어봤다. procedure call = new environment creation 이라고 인식하게 됬다. 지금 들여다보고있는 이 내용이 `closure` 인건가 싶다. 만약 맞다면, 앞으로 누군가 `closure` 의 개념에 대해 묻는다면 SICP 의 Chapter 3.2 를 추천해주고 싶다.
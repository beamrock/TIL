## 정적 팩터리 메서드(static factory method)
가능하다면 생성자 대신 정적 팩터리 메서드를 제공하도록 설계하라는 규칙이다. **Boolean** 클래스의 예를 들 수 있다. 여러 참조 변수가 같은 Boolean 인스턴스를 가리키므로 아마 final 로 선언되었을 것이다.
```java
public static Boolean valueOf(boolean b) {
	return b? Boolean.TRUE : Boolean.FALSE;
}
```
생성자 대신 정적 팩터리 메서드를 사용했을 때의 장점을 책은 아래와 같이 소개한다.
* 정적 팩터리 메서드에는 **이름**이 있으므로, 클래스를 사용하는 유저가 의미를 파악하기 쉽다. 또한 동일한 시그니처의 생성자는 만들 수 없지만, 동일한 시그니처의 정적 팩터리 메서드는 이름을 달리해서 만들 수 있다.
* 생성자는 호출될때마다 새로운 인스턴스가 만들어지지만, 정적 팩터리 메서드에서는 꼭 그럴 필요가 없다. 인스턴스를 내부에 품고 **재사용**할 수도 있다.
* 정적 팩터리 메서드를 사용할 경우, 해당 클래스의 인스턴스 뿐 아니라 **하위 타입**의 인스턴스를 반환할 수도 있다. 그러므로 public 으로 선언되지 않은 클래스의 인스턴스도 반환할 수 있다. 
* 책에서는 네번째 장점으로, 정적 팩터리 메서드는 **형인자 자료형(parameterized type)** 객체를 만들 때 편하다고 얘기한다. 하지만 JDK 1.7 부터는 생성자에서도 타입 추론(type inference)을 해준다.

장점뿐 아니라 단점도 소개한다.
* 정적 팩터리 메서드"만" 사용할 경우 public/protected 로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.
* 다른 정적 팩터리 메서드와 확연히 구분되지 않아 유저들에게 혼란을 줄 수 있다.

## Builder 패턴
생성자의 인자가 많은 경우에는 정적 팩터리 메서드나 생성자나 문제가 생긴다. 생성자의 개수가 많아져서 코드를 읽기 힘들어지고, 생성자에 많은 인자를 넘기면서 각각의 인자의 순서나 의미를 파악하기 힘들어진다. 

첫번째 방법은 **점층적 생성자 패턴**(telescoping constructor pattern)이다. 언뜻 깔끔해보이지만 인자의 개수가 점점 많아질수록 코드는 더욱 복잡해진다.

두번째 방법은 **자바빈(JavaBeans) 패턴**이다. 인자없는 생성자만 제공하고, 클래스 정의에 모든 필드들의 기본값이 선언되어있고, 모든 필드에 대한 setter 를 제공한다. 인자의 개수가 늘어나도 기본값 선언 / setter 만 추가하면 되므로 두줄로 충분하다. 하지만 모든 setter 들이 상호독립적으로 동작하므로 인스턴스의 일관성을 유지할 수 없다.

두가지 방법을 결합한 세번째 방법이 바로 빌더(Builder) 패턴이다.
* 필수 필드들을 받는 생성자 or 정적 팩터리 메서드에 전달해서 빌더 인스턴스를 만든다. 빌더 클래스는 보통 타겟이 되는 클래스의 정적 멤버 클래스로 정의한다.
* 설정 메서드들로 선택 인자들을 추가한다.
* build() 메서드로 변경 불가능 인스턴스를 만든다.

## Singleton
싱글턴을 구현하는 가장 좋은 방법은, 원소가 하나뿐인 enum 자료형으로 정의하는 것이다.

## private 생성자
인스턴스의 생성을 원치 않는 Utility 클래스를 만들때는 private 생성자를 선언하자. 해당 클래스의 인스턴스 생성도 막을 수 있고, 하위 클래스 정의도 막을 수 있다.

## Finalizer
종료자는 쓰지 않는다. GC 가 언제 종료자를 호출해줄지, 그리고 언제가 호출해주기는 할지 그 어느것도 보장받지 못하기 때문이다. 

대신에 명시적인 **종료 메서드(termination method)**를 하나 정의하고 클라이언트가 해당 메서드를 호출하도록 유도한다. 또한 클래스에 종료 여부를 기록하는 필드를 둬서, 종료 메서드가 호출된 후에 다른 메서드를 호출하려고 시도할 경우 `IllegalStateException` 예외를 던지도록 한다. JDK 1.7 부터는 try-with-resources 문법과 함께 사용할 수 있다.
## equals 오버라이딩 = 선택
* 객체 동일성(object equality)가 아니라 논리적 동일성(logical equality)의 개념을 지원하는 클래스라면 equals 메서드의 오버라이딩을 고려할 만하다.
* 슥슥 읽어나가다가 **상위 클래스에 없는 새로운 값 컴포넌트(value component)를 하위 클래스에 추가하는 상황**에 대한 **추이성(transitivity)** 문제에 주목했다. 객체 생성 가능(instantiable) 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법은 없다고 한다. 해결방법은 계승하는 대신 구성(composition) 하는 것이다.
* **java.sql.Timestamp** 는 **java.util.Date** 를 계승하고 nanoseconds 필드를 추가했으므로 위의 원칙을 위배한다. JDK 에도 이런 사례가 있다니 놀랍다.
* **java.net.URL** 의 equals 메서드는 URL에 대응되는 호스트의 IP 주소를 비교하는데, 이는 네트워크가 필요한 작업이며, 시간에 따라 결과가 바뀔 수 있으므로 일관성(consistency) 원칙에 위배된다. 이 또한 놀랍다.
* equals 메서드의 인자로 null 이 들어오는지 여부는 따로 검사할 필요가 없다. `MyType` 이라는 이름의 클래스의 equals 메서드라면 `o instance of MyType` 조건 확인으로 충분하다.
* 성능을 위해서 equals 메서드의 로직을 구성하는 여러 로직들 중에서 가장 다를 가능성이 크거나, 연산이 저렴한 것들을 앞에 배치하자.

## equals 오버라이딩 --> hashCode 오버라이딩 필수
* 돌이켜 생각해보니 지금껏 여러 클래스들을 정의해놓고도 hashCode 메서드를 오버라이딩한 적이 없다. Map 을 사용할때 정의한 클래스들을 key 로 넣은적이 없었기에 문제가 되지 않았나보다. 늘 key 로는 기본 자료형을 사용했었다. 
* 그러나 새로 정의한 클래스를 key 로 사용할 경우, hashCode 메서드를 오버라이딩하지 않으면 Map 에서 get 메서드를 호출할때 equals 로 동일한 두 인스턴스를 넣어도 다른 결과가 나온다.
* 이상적인 해시 함수는 임의의 인스턴스를 가능한 해시 값에 균등하게 배분한다. 이상적인 해시 함수에 "가까운" 해시 함수를 만드는 방법이 책에 기술되어있으니 참고하자.

## toString 오버라이딩 = 필수
* "사람이 읽기 쉽도록 **간략**하지만 **유용한 정보**를 제공해야 한다."
* 값 클래스의 경우 toString 메서드를 잘 만들어두면 String <-> 인스턴스 변환이 용이해진다. 하지만 이게 좋은 경우도 있지만 나쁜 경우도 있다.
* toString 메서드를 오버라이딩 하고, 그 의도를 명확히 주석으로 남겨야한다. 책에 좋은 예시가 소개되어있다.
* toString 메서드를 구성하는 필드들에 대한 getter 를 제공하라. 그렇지않으면 유저들은 toString 의 결과물로부터 정보들을 파싱하려고 시도할 것이다.

## clone 오버라이딩 = 기피 대상
* Cloneable 을 구현하는 모든 클래스는 반환값 자료형이 자기 자신인 public clone 메서드를 재정의해야 한다.
* 이 메서드는 맨 처음에 super.clone 을 호출해야 한다.
* 그 후 primitive 가 아니고, final 이 아닌 필드들은 따로 deepCopy 해줘야한다.
* 그러나 이 모든 일련의 과정들이 너무나 복잡하고, 또한 필수적이지도 않다!
* 객체 복제를 지원하는 좋은 방법은, **복사 생성자(copy constructor)** 나 **복사 팩터리(copy factory)** 를 제공하는 것이다.
* Cloneable 을 계승하는 인터페이스는 만들지 말아야 하며, 계승 목적으로 설계하는 클래스는 Cloneable 을 구현하지 말아야 한다.

## Comparable 구현
* compareTo 메서드는 **ClassCastException** 을 발생시킬 수 있다.
* 부동소수점 필드는 **Float.compare** 나 **Double.compare** 메서드를 사용해야 한다. 관계 연산자를 쓰면 안된다.
* equals 메서드는 Object 클래스의 것을 오버라이딩 하므로 시그니처로 Object 타입을 받았다. 하지만 Comparable 인터페이스는 제네릭 타입이므로 compareTo 메서드의 시그니처도 해당 클래스 타입으로 고정할 수 있어서 구현이 편리하다.
* 하지만 마찬가지로 변경가능한 필드를 추가하면서 compareTo 메서드를 구현한 클래스를 계승하는것은 불가능하다. 추가된 필드를 고려해서 compareTo 메서드를 오버라이딩 할 수 없기 때문이다. equals 메서드와 마찬가지로 계승하지 않고 구성해서 문제를 해결한다.
## 접근 권한은 가능한 낮추라
접근 권한을 가능한 낮추는 것이 캡슐화(encapsulation)을 따르는 것이다. 이를 통해 의존성 완화(decoupling), 성능 튜닝(tuning), 프로파일링(profiling) 등이 용이해진다.

* 최소한의 public API 를 설계한 다음, 다른 모든 클래스, 인터페이스, 멤버는 API 에서 제외한다.
* public static final 필드를 제외한 어느 필드도 public 필드로 선언하지 않는다.
* public static final 필드가 참조하는 객체는 **변경 불가능 객체**로 만든다.

## public 필드 선언 대신 접근자 메서드를 제공하라
Java 라이브러리 클래스 가운데도 이를 따르지 않는 예가 두가지 소개됬다. 이들 클래스들은 가능한 참조하지 말라고 조언하고 있다.

* java.awk 의 Point
* java.awk 의 Dimension

## 변경 가능성을 최소화하라

* 수정자(mutator) 메서드를 제공하지 않는다.
* 계승할 수 없도록 클래스를 final 로 선언한다.
* 모든 필드를 final 로 선언한다.
* 모든 필드를 private 로 선언한다.

복소수를 나타내는 `Complex` 클래스를 예시로 들었다. 복소수를 나타내므로 사칙연산 메서드를 제공하는데, 각각이 메서드가 호출된 인스턴스의 상태를 변화시키는 것이 아니라 새로운 `Complex` 인스턴스를 생성해서 반환한다. 이를 함수형 접근법(functional approach)라고 부른다고 한다.

* 변경 불가능 객체는 thread-safe 할 수 밖에 없다. 그러므로 동기화가 필요없다.
* 변경 불가능 클래스에는 clone 메서드나 복사 생성자를 만들 필요도 없고, 만들어서도 안 된다.
* 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.
* 변경 가능한 클래스로 만들 타당한 이유가 없다면, 반드시 변경 불가능 클래스로 만들어야 한다.
* 변경 불가능한 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한해야 한다.
* 특별한 이유가 없다면 모든 필드는 final 로 선언하라.

## 계승하는 대신 구성하라
* 같은 개발자가 상위 클래스와 하위 클래스를 모두 설계하거나, 상위 클래스 개발자가 계승을 고려해서 설계하고 이를 잘 문서화해놓지 않은 이상 계승하는 것은 위험하다. 유저가 설계한 하위 클래스의 동작이 언제나 상위 클래스에 의존하므로 새로운 릴리즈 마다 하위 클래스 동작이 깨질 위험이 있기 때문이다.
* composition, forwarding, forwarding method, wrapper class, decorator pattern
* 구성의 유일한 단점은, 역호출(callback) 프레임워크에 부적절하다는 것이다. wrapper -> wrapped 의 메서드를 호출한 뒤에 wrapped 가 wrapper 을 역호출할 수는 없기 때문이다.
* 자바 플랫폼 라이브러리에는 반례로, Stack 이 Vector 를 계승하는 것과 Properties 가 HashTable 을 계승하는 것이 있다. 그러면 안되는거였다.

## 추상 클래스 대신 인터페이스를 사용하라
* 인터페이스는 믹스인(mixin)을 정의하는 데 이상적이다.
* (Java 8 부터는 default 키워드가 생겼지만) 인터페이스의 장점을 살리면서, 유저에게 구현도 제공하고 싶은 경우에는 인터페이스를 정의하고 그에 대한 기본 골격 클래스를 추상 클래스로 제공하면 된다. Collection Framework 가 대표적인 예이다. AbstractList, AbstractMap, AbstractSet ... 등이 제공된다.
* (Java 8 부터는 default 키워드가 생겼지만) 인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불가능하므로 신중하게 설계해야 한다.

## 인터페이스는 자료형을 정의할 때만 사용하라
* 상수 인터페이스는 만들지 마라. 인터페이스를 구현하는 하위 클래스들의 네임 스페이스를 번잡하게 만든다.
* 상수 인터페이스 대신 필요하다면 상수 유틸리티 클래스를 사용하라.

## 태그 달린 클래스 대신 클래스 계층을 활용하라
* 태그 달린 클래스란, 클래스에 달린 태그에 따라 클래스 메서드의 로직이 달라지는 클래스를 의미한다. 번잡하다. 태그에 따라 달라지는 부분을 빼서 추상 클래스의 추상 메서드로 만들고, 달라지는 로직은 하위 클래스에서 구현하도록 하라.

## 전략을 표현하고 싶을 때는 함수 객체를 사용하라
* 함수 포인터(function pointer), 대리자(delegate), 람다 표현식(lambda expression) 등은 특정 함수를 호출할 수 있는 능력을 저장하고, 전달 될 수 있다.
* 전략(strategy) 패턴이라는게 있다. 인자에 따라 메서드의 기능이 달라진다. 정렬 메서드가 비교자(comparator) 를 인자로 받는 상황을 예로 들 수 있다.
* 책에서는 **함수 객체(function object)** 에 대해서 얘기한다. Java 8 부터는 람다 표현식이 제공되므로 더 편리해졌다.
* 제네릭에서 T 를 형식 **자료형 인자(formal type parameter)** 라고 부른다는 사실을 덤으로 알게되었다. 
* 한번만 사용되는 경우에는 실행 가능 전략 클래스를, 해당 인터페이스를 구현하는 익명 클래스로 만들면 된다. 여러번 사용되는 경우에는 private static 멤버 클래스로 전략을 표현한 다음, 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공개하면 좋다. 전략 인터페이스의 예는 Comparator<T> 를 들 수 있다. 이렇게 하면 유저는 구체적인 실행 가능 전략 클래스의 타입을 신경 쓸 필요가 없다.

## 멤버 클래스는 가능하면 static 으로 선언하라
* 비-정적 멤버 클래스는 기본으로 바깥 클래스를 가리키는 참조를 가지므로, 꼭 필요하지 않은 상황이라면 낭비가 된다. **어댑터(Adaptor)** 를 정의할때 많이 쓰인다.
* 익명 클래스는 **함수 객체** 를 정의할때 널리 쓰인다. 또한 **프로세스 객체(process object, Runnable / Thread / TimerTask 등)** 을 만드는 데도 널리 쓰인다.
* 지역 클래스에 대해서는 별로 기록하고 싶지 않다.
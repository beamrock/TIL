## 규칙 30: int 상수 대신 enum을 사용하라
* enum 은 **열거 상수(enumeration constant)** 별로 하나의 객체를 **public static final** 필드로 제공하는 셈이다.
* enum 자료형은 컴파일 시점 **형 안전성(compile-time type safety)** 를 제공한다.
* enum 자료형에 데이터를 넣으려면 private final 로 필드를 선언하고 생성자에서 값을 저장하면 된다. public 접근자를 제공하라.
* 정적 `values()` 메서드는 모든 enum 상수를 선언된 순서대로 반환한다.
* **상수별 메서드 구현(constant-specific method implementation)** 의 개념이 재밌다. enum 상수에 abstract 메서드를 정의해두고, 각 상수 선언에서 구현한다.
* enum 상수에는 기본으로 **valueOf(String)** 메서드가 있다. 상수의 이름으로 상수를 획득하는 메서드이다. 필요에 의해서 enum 상수의 `toString()` 메서드를 재정의했다면, `fromString(String)` 메서드도 정의해서 역변환 기능을 제공할지 고민하라.
* 여러 enum 상수가 공통 기능을 이용해야 하는 일이 생길 때는 **정책 enum 패턴** 사용을 고려하라. 내부 enum 상수를 정의하면서 정책을 표현하고, 외부 enum 의 생성자에서 내부 enum 을 꼭 선택하도록 한다.

## 규칙 31: ordinal 대신 객체 필드를 사용하라
* 이름 그대로의 짧은 규칙이다. enum 상수들은 `ordinal()` 메서드를 가지고 있어서 자신이 몇번째로 선언된 상수인지 반환한다. 하지만 이를 통해 어떤 정보를 나타내려고 하지 말라는 얘기다. enum 상수마다 고유한 정수값을 선언하고 싶다면, private final int 필드를 선언하고 생성자와 접근자를 정의하면 된다.

## 규칙 32: 비트 필드(bit field) 대신 EnumSet 을 사용하라
* **비트 필드**의 개념은 1 << 0 (1), 1 << 1 (2), 1 << 2 (4), ... 의 상수들 각각이 집합의 원소를 나타내도록 해서 비트 연산으로 임의의 정수와 집합을 대응시키는 개념이다. 그러나 상수집합을 나타내기에 더 적절한 **EnumSet** 이 있으므로 비트 필드를 만들어 쓰지 말라는 규칙이다. EnumSet 이 내부에서 비트 벡터(bit vector)를 사용한다.
* EnumSet 은 Set 을 구현하므로 코드 호환성도 좋다.
* 단점 한가지는 immutable 하지 않다는 점인데, 이는 Guava 라이브러리를 사용하면 좋다.

## 규칙 33: ordinal 을 배열 첨자로 사용하는 대신 EnumMap 을 이용하라
* enum 상수별로 어떤 타입을 매칭시키고 싶을때 **EnumMap** 을 쓰면 아주 좋다. 책에는 enum 상수의 ordinal() 을 인덱스로 하는 배열을 사용하는 경우를 소개하는데, 오히려 이 방법이 더 변태같아서 이해하기 힘들었다. <K. V> 제네릭에서 K 가 enum 타입이 들어가고, EnumMap 생성자는 추가로 enum 타입의 클래스 클래스 리터럴을 받는다. 
* 정확한 표현은 클래스 리터럴이 아니라, **한정적 자료형 토큰(bounded type token)** 이라고 부르나보다.
* 2차원 배열이 필요할법한 상황이라면 문제는 더 심각해지고, 반대로 EnumMap 의 우아함은 더 깊어진다. (이전 상태, 이후 상태) 를 상전이와 연관짓는 예제가 있었다.

## 규칙 34: 확장 가능한 enum 을 만들어야 한다면 인터페이스를 이용하라
* enum 은 계승할 수 없다는 단점이 있지만, 대부분의 경우 애초에 계승할 필요가 없다.
* enum 은 계승한다기보다, 확장된다는 표현이 맞을 것 같다. 확장되도록 만들고 싶다면, enum 에 구현하고자 하는 로직을 인터페이스로 정의하고, enum 이 인터페이스를 구현하도록 한다. 이 경우 enum 상수 하나하나가 해당 인터페이스 구현체 인스턴스 하나가 되는 셈이다.
* 그러고나면 확장하고 싶을때, 새로운 enum 을 정의하고 동일한 인터페이스를 구현하도록 한다.
## MySQL 설정

[Accessing data with MySQL](https://spring.io/guides/gs/accessing-data-mysql/) 가이드를 정독하면 된다.

### build.gradle

```groovy
dependencies {
    ...
    compile('mysql:mysql-connector-java')
}
```

### src/main/resources/application.properties

```
spring.jpa.hibernate.ddl-auto=create
spring.datasource.url=jdbc:mysql://localhost:3306/db_example
spring.datasource.username=springuser
spring.datasource.password=ThePassword
```

### storage engine issue

hibernate 는 기본 설정으로 MyISAM storage engine 을 사용한다. stack overflow 답변들을 보면 InnoDB 를 사용하기 위해선 아래와 같이 property 를 선언하라고 한다. **spring.jpa.properties** prefix 를 달아주면 spring 이 알아서 library 들에게 forward 해준다고 한다.

```
# application.properties
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect

# console
org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL5InnoDBDialect

# create table
create table Dummy1 (
    id integer not null, 
    primary key (id)
) engine=InnoDB
```

그런데 `MySQL5InnoDBDialect` 의 javadoc 을 보면 `@deprecated Use "hibernate.dialect.storage_engine=innodb" environment variable or JVM system property instead.` 라고 적혀있다. 그러니 application.properties 에 선언하는게 아니라, env 를 추가하거나 java 실행할때 system property 로 넘겨야할 것이다.

## @Id 와 @GenerationType

application 에서 model class 를 선언하고, database table 로 만들어지기를 희망하는 마음으로 `@Entity` 를 달아준다. 이때 필수로 model class 의 field 중 적어도 하나에 `@Id` 를 달아서 primary key 를 명시해야한다. 그러지 않으면 `AnnotationException` 를 던진다.

이때 직접 model class 생성자에 id field 값을 넣어줄수도 있고, hibernate 가 알아서 만들게 할 수도 있다. 전자의 경우 entity instance 에 id field 의 값을 assign 하지 않은채로 persist 를 시도하면 `IdentifierGenerationException` 를 던진다. 후자를 위해서는 `@Id` 를 단 field 에 `@GeneratedValue` 를 달아준다. 이때 strategy 로 `GenerationType` enum 중 하나를 넘겨줄 수 있다. default 는 `AUTO` 인데, 이 경우 persistence provider 가 database 에 따라 적절한 strategy 를 선택해준다. default database 인 H2 와 MySQL 2가지를 경험해봤는데 차이가 있었다.

### H2

H2 는 database sequence 를 제공해주므로 `SEQUENCE` 를 사용한다.

```sql
drop sequence if exists hibernate_sequence
create sequence hibernate_sequence start with 1 increment by 1

-- insert 직전
call next value for hibernate_sequence
```

### MySQL

MySQL 은 database sequence 를 제공해주지 않는다. default 로 `TABLE` 을 사용한다.

```sql
drop table if exists hibernate_sequence
create table hibernate_sequence ( next_val bigint ) engine=InnoDB
-- @Entity 달린 class 개수만큼 반복
insert into hibernate_sequence values ( 1 )

-- insert 직전
select next_val as id_val from hibernate_sequence for update
update hibernate_sequence set next_val= ? where next_val=?
```

`hibernate_sequence` 테이블을 초기화할때 왜 굳이 `@Entity` 달린 class 개수만큼 record 를 insert 하는지는 의문이다.

`TABLE` 대신 `IDENTITY` 를 쓸 수도 있다. MySQL 의 auto\_increment 를 사용한다. create table 에서 id column 의 column definition 에 구문이 추가된다.

```sql
create table Post (
    id integer generated by default as identity,
    primary key (id)
)
```

insert 할때 id 를 명시해야하기 때문에 이전값이 필요한`TABLE` 과 달리, `IDENTITY` 는 id 를 명시하지 않아도 dbms 가 알아서 auto\_increment integer 를 만들어주기때문에 바로 insert 할 수 있다. repository 로 save 한 뒤에 entity instance 의 id field 에 값이 채워지는데, console log 를 봤을때 select query 가 없어서 신기했다. 찾아보니, insert 한 stmt 의 `Statement#getGeneratedKeys` method 로 사용된 auto\_increment 값을 얻을 수 있었다. [6.4 Retrieving AUTO_INCREMENT Column Values through JDBC](https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-usagenotes-last-insert-id.html)

## 규칙 23
* 선언부에 **형인자(type parameter)** 가 포함된 클래스나 인터페이스는 **제네릭(generic)** 클래스나 인터페이스이라고 부른다. 제네릭 클래스와 인터페이스는 **제네릭 자료형(generic type)** 이라 부른다.
* 각 제네릭 자료형은 **형인자 자료형(parameterized type)** 집합을 정의한다. 이 집합은 이름 뒤에 <와 > 기호로 감싼 **실 형인자(actual type parameter)** 목록이 붙은 클래스나 인터페이스 들로 구성된다. 이 실 인자들은 제네릭 자료형의 **형식 형인자(formal type parameter)** 각각에 대응된다.
* 마지막으로, 각 제네릭 자료형은 새로운 **무인자 자료형(raw type)** 을 정의한다. 예를 들어 List<E> 에서 무인자 자료형은 List 이다. 새로운 코드에서는 이런 무인자 자료형을 쓰지 말라는 것이 규칙 23이다. 제네릭 이전의 Java collection 에서는 이러한 무인자 자료형을 사용했고, 그러므로 암묵적으로 특정 자료형을 보관하는 collection 을 선언해서 사용했을 지라도, 다른 자료형의 원소를 집어넣어도 컴파일 에러가 발생하지 않았다. 그리고 코드에서 매번 새로운 원소를 꺼낼때마다 명시적으로 형 변환(type casting) 을 해줘야했다.
* 제네릭이 나오기 이전에 쓰여진 수없이 많은 코드들에 대한 **이전 호환성(migration compatibility)** 가 문제가 된 것이다.   
* 제네릭을 쓰고 싶으나, 실 형인자에 대해서 신경쓰고 싶지 않은 경우에는 **비한정적 와일드카드 자료형(unbounded wildcare type)** 을 사용하면 된다. Set<?> 등이 그 예다.
* 첫번째 예외는 **클래스 리터럴(class literal)** 을 사용하는 경우다. List.class 를 써야하고, List<String>.class 는 사용할 수 없다. 두번째 예외는 **instanceof** 를 사용하는 경우다. 런타임에 제네릭 자료형의 실 형인자는 지워지므로 instanceof 의 대상은 무인자 자료형만 가능하다.

```java
if (o instanceof Set) {
	Set<?> m = (Set<?>) o;
}
```
* 책 마지막 장에 나오는 표가 아주 훌륭하다. 등장한 복잡한 단어들을 모두 예시로 소개한다.

## 규칙 24
* 제네릭으로 프로그래밍 하다보면 **무점검 경고(unchecked warning)** 을 많이 만나게 된다. 이를 제거하라는 규칙이다. 
* 제거할 수 없는 경고 메시지는 형 안전성이 확실할 때만 **@SuppressWarnings("unchecked")** 어노테이션을 사용해서 억제한다.
* 어노테이션을 사용해서 억제할때마다, 왜 형 안전성을 위반하지 않는지 밝히는 주석을 반드시 붙이라 한다. 형 안전성이란 **ClassCastException** 을 발생시키지 않음을 의미하나보다.

## 규칙 25
* 배열은 **공변 자료형(covariant)** 이고, 제네릭은 **불변 자료형(invariant)** 이다.
* 배열은 **실체화(reification)** 되는 자료형이고, 제네릭은 그렇지 않다. 제네릭은 컴파일 과정에서 타입 정보가 **삭제(erasure)** 된다. 그러므로 배열과 제네릭을 혼용하기 힘들다.
* 배열은 컴파일 시간에 형 안전성을 보장하지 못한다(?). 그러니 혼용하다가 컴파일 오류나 경고 메시지를 만나게 되면, 배열을 리스트로 바꾸자.

## 규칙 26
* 가능하면 제네릭 자료형으로 만들라는 규칙이다. 제네릭을 쓸만한 상황에서 일반화를 위해 Object 타입을 덕지덕지 붙이다보면, 이를 사용하는 유저 입장에서 매번 형 변환을 해줘야하므로 불편하다. 그러니 제네릭을 사용하라는 얘기였다. 

## 규칙 27
* 규칙 26과 마찬가지로, 가능하면 메서드를 설계할때도 제네릭 메서드로 만들라는 규칙이었다.
* 제네릭과 관련해서는 전반적으로 잘 와닿지가 않는다.
